MODULE input
VAR
    num_p : 0..50;
INIT num_p in 0;


MODULE output
VAR 
    num_p : 0..50;
INIT num_p in 0;

MODULE source_1(output)
DEFINE
    capB := 50;
    sr := 2;
VAR
    p_buffer : 0..capB;
    state : {start, congestion};
ASSIGN
    init(state) := start;
    next(state) := start;
    init(p_buffer) := 10;
    next(p_buffer) :=
        case
            state = start & p_buffer >= sr : p_buffer - sr;
            TRUE : p_buffer;
        esac;
    next(output.num_p) :=
        case
            state = start & p_buffer >= sr & output.num_p <= 50 - sr : output.num_p + sr;
            TRUE : output.num_p;
        esac;

MODULE intermediate_2(input, output)
DEFINE
    capB := 50;
    rr := 2;
	sr := 2;
    cond_congestion := (p_buffer / capB) > (7 / 10);
VAR
    p_buffer : 0.. capB;
    state : {start, congestion};
IVAR
    action : {receive, send};
ASSIGN
    init(state) := start;
    next(state) := 
        case
            cond_congestion : congestion;
            TRUE : state;
        esac;
    init(p_buffer) := 0;
    next(p_buffer) :=
        case
            state = start & action = receive & input.num_p >= rr & p_buffer <= capB - rr : p_buffer + rr;
            state = start & action = send & p_buffer >= sr : p_buffer - sr;
			TRUE : p_buffer;
		esac;
	next(input.num_p) :=
		case
			state = start & action = receive & input.num_p >= rr : input.num_p - rr;
			TRUE : input.num_p;
		esac;
	next(output.num_p) :=
		case
			state = start & action = send & p_buffer >= sr & output.num_p <= 50 - sr : output.num_p + sr;
			TRUE : output.num_p;
		esac;

MODULE sink_3(input)
DEFINE
	capB := 50;
	rr := 2;
VAR
	p_buffer : 0..capB;
	state : {start, congestion};
ASSIGN
    init(state) := start;
    next(state) := start;
	init(p_buffer) := 0;
	next(p_buffer) :=
		case
			state = start & input.num_p >= rr & p_buffer <= capB - rr : p_buffer + rr;
			TRUE : p_buffer;
		esac;
	next(input.num_p) :=
		case
			state = start & input.num_p >= rr : input.num_p - rr;
			TRUE : input.num_p;
		esac;

MODULE channel_1_2(sensor_output, sensor_input)
DEFINE
    capB := 50;
    rr := 2;
	sr := 2;
VAR
    p_buffer : 0.. capB;
IVAR
    action : {receive, send};
ASSIGN
    init(p_buffer) := 0;
    next(p_buffer) :=
        case
            action = receive & sensor_output.num_p >= rr & p_buffer <= capB - rr : p_buffer + rr;
            action = send & p_buffer >= sr : p_buffer - sr;
			TRUE : p_buffer;
		esac;
	next(sensor_output.num_p) :=
		case
			action = receive & sensor_output.num_p >= rr : sensor_output.num_p - rr;
			TRUE : sensor_output.num_p;
		esac;
	next(sensor_input.num_p) :=
		case
			action = send & p_buffer >= sr &sensor_input.num_p <= 50 - sr : sensor_input.num_p + sr;
			TRUE : sensor_input.num_p;
		esac;

MODULE channel_2_3(sensor_output, sensor_input)
DEFINE
    capB := 50;
    rr := 2;
	sr := 2;
VAR
    p_buffer : 0.. capB;
IVAR
    action : {receive, send};
ASSIGN
    init(p_buffer) := 0;
    next(p_buffer) :=
        case
            action = receive & sensor_output.num_p >= rr & p_buffer <= capB - rr : p_buffer + rr;
            action = send & p_buffer >= sr : p_buffer - sr;
			TRUE : p_buffer;
		esac;
	next(sensor_output.num_p) :=
		case
			action = receive & sensor_output.num_p >= rr : sensor_output.num_p - rr;
			TRUE : sensor_output.num_p;
		esac;
	next(sensor_input.num_p) :=
		case
			action = send & p_buffer >= sr &sensor_input.num_p <= 50 - sr : sensor_input.num_p + sr;
			TRUE : sensor_input.num_p;
		esac;

MODULE main

VAR
	source_1 : process source_1(output_1);
	output_1 : output;

	sink_3 : process sink_3(input_3);
	input_3 : input;

    intermediate_2 : process intermediate_2(input_2, output_2);
    input_2 : input;
    output_2 : output;        

	channel_1_2 : process channel_1_2(output_1,input_2);
    
    channel_2_3 : process channel_2_3(output_2,input_3);

LTLSPEC G F intermediate_2.state = congestion;


